from django.db import models
from django.urls import reverse
from django.utils import timezone
from django.contrib.auth.models import User
from datetime import date, datetime, time, timedelta
import uuid

from .base import Campaign
from .content import Encounter


class SessionNote(models.Model):
    encounter = models.ForeignKey(
        Encounter,
        on_delete=models.CASCADE,
        related_name="session_notes",
        null=True,  # Allows NULL in the database
    )
    date = models.DateField(default=timezone.now)
    content = models.TextField(help_text="Use bullet points or markdown.")
    summary = models.TextField(blank=True, help_text="Generated by LLM")
    owner = models.ForeignKey(
        User, on_delete=models.CASCADE, related_name="session_notes"
    )

    def __str__(self):
        return f"Session on {self.date} - {self.encounter.title if self.encounter else 'Unknown'}"


class ChatMessage(models.Model):
    campaign = models.ForeignKey(
        Campaign, on_delete=models.CASCADE, related_name="chat_messages"
    )
    role = models.CharField(
        max_length=10, choices=[("user", "User"), ("assistant", "Assistant")]
    )
    content = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
    ordering = ["created_at"]
    confirmed_for_chapter = models.BooleanField(default=False)

    def __str__(self):
        return f"{self.role}: {self.content[:40]}"


class ChapterChatMessage(models.Model):
    campaign = models.ForeignKey(
        Campaign, on_delete=models.CASCADE, related_name="chapter_chat_messages"
    )
    role = models.CharField(
        max_length=10, choices=[("user", "User"), ("assistant", "Assistant")]
    )
    content = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
    confirmed_for_generation = models.BooleanField(default=False)

    def __str__(self):
        return f"{self.role}: {self.content[:40]}"


class SessionSchedule(models.Model):
    STATUS_CHOICES = [
        ("collecting", "Collecting Responses"),
        ("ready", "Ready to Schedule"),
        ("scheduled", "Session Scheduled"),
        ("completed", "Session Completed"),
        ("cancelled", "Cancelled"),
    ]

    campaign = models.ForeignKey(
        Campaign, on_delete=models.CASCADE, related_name="session_schedules"
    )
    owner = models.ForeignKey(
        User, on_delete=models.CASCADE, related_name="session_schedules"
    )

    title = models.CharField(max_length=200, default="Session Availability")
    date_range_start = models.DateField(
        default=date.today(), help_text="Start of the date range for potential sessions"
    )
    date_range_end = models.DateField(
        default=date.today() + timedelta(weeks=4),
        help_text="End of the date range for potential sessions",
    )

    shareable_token = models.UUIDField(default=uuid.uuid4, unique=True, editable=False)
    status = models.CharField(
        max_length=20, choices=STATUS_CHOICES, default="collecting"
    )

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    # Scheduling configuration
    weekday_start_time = models.TimeField(
        default=time(19, 0),
        help_text="Start time for weekday availability (e.g., 19:00)",
    )
    weekday_end_time = models.TimeField(
        default=time(22, 0), help_text="End time for weekday availability (e.g., 22:00)"
    )
    weekend_start_time = models.TimeField(
        default=time(12, 0),
        help_text="Start time for weekend availability (e.g., 12:00)",
    )
    weekend_end_time = models.TimeField(
        default=time(22, 0), help_text="End time for weekend availability (e.g., 22:00)"
    )
    slot_duration_hours = models.PositiveIntegerField(
        default=3, help_text="Duration of each time slot in hours"
    )
    slot_overlap_hours = models.PositiveIntegerField(
        default=2,
        help_text="Hours of overlap between consecutive slots (0 for no overlap)",
    )
    include_weekdays = models.BooleanField(
        default=True, help_text="Include weekdays in scheduling options"
    )

    class Meta:
        ordering = ["-created_at"]

    def __str__(self):
        return f"{self.title} - {self.campaign.title}"

    def get_absolute_url(self):
        return reverse("campaigns:session_schedule_detail", args=[str(self.id)])

    def get_player_url(self):
        return reverse(
            "campaigns:player_availability", args=[str(self.shareable_token)]
        )

    @property
    def total_responses(self):
        return self.player_availabilities.count()

    @property
    def can_schedule(self):
        return self.status == "collecting" and self.total_responses > 0

    def get_date_range(self):
        """Get list of dates within the configured range"""
        dates = []
        current = self.date_range_start
        while current <= self.date_range_end:
            # Filter by weekday/weekend based on settings
            is_weekend = current.weekday() in [5, 6]  # Sat, Sun
            if is_weekend or self.include_weekdays:
                dates.append(current)
            current += timedelta(days=1)
        return dates

    def is_weekend(self, date):
        """Check if a date is a weekend (Saturday, Sunday)"""
        return date.weekday() in [5, 6]

    def generate_time_slots_for_date(self, date):
        """Generate time slots for a specific date based on configuration"""
        is_weekend = self.is_weekend(date)

        # Get appropriate start and end times
        if is_weekend:
            start_time = self.weekend_start_time
            end_time = self.weekend_end_time
        else:
            start_time = self.weekday_start_time
            end_time = self.weekday_end_time

        # Convert to datetime for calculation
        start_dt = datetime.combine(date, start_time)
        end_dt = datetime.combine(date, end_time)

        slots = []
        current_start = start_dt

        # Calculate step size (duration - overlap)
        step_minutes = (self.slot_duration_hours - self.slot_overlap_hours) * 60

        while current_start < end_dt:
            slot_end = current_start + timedelta(hours=self.slot_duration_hours)

            # Don't add slots that extend beyond the end time
            if slot_end <= end_dt:
                slot_label = (
                    f"{current_start.strftime('%H:%M')} - {slot_end.strftime('%H:%M')}"
                )
                slots.append(
                    {
                        "label": slot_label,
                        "start_time": current_start.time(),
                        "end_time": slot_end.time(),
                    }
                )

            current_start += timedelta(minutes=step_minutes)

            # Safety check to prevent infinite loops
            if step_minutes == 0:
                break

        return slots

    def get_all_time_slots_by_date(self):
        """Get all time slots organized by date"""
        slots_by_date = {}
        for date in self.get_date_range():
            slots_by_date[date.strftime("%Y-%m-%d")] = (
                self.generate_time_slots_for_date(date)
            )
        return slots_by_date


class PlayerAvailability(models.Model):
    session_schedule = models.ForeignKey(
        SessionSchedule, on_delete=models.CASCADE, related_name="player_availabilities"
    )
    player_name = models.CharField(max_length=100)
    character_name = models.CharField(max_length=100, blank=True)
    email = models.EmailField()

    # Store availability as JSON: {date: [time_slots]}
    availability_data = models.JSONField(default=dict)

    submitted_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        ordering = ["submitted_at"]
        unique_together = ["session_schedule", "email"]

    def __str__(self):
        return f"{self.player_name} - {self.session_schedule.title}"

    def get_availability_for_date(self, date_str):
        return self.availability_data.get(date_str, [])

    def set_availability_for_date(self, date_str, time_slots):
        self.availability_data[date_str] = time_slots


class ScheduledSession(models.Model):
    STATUS_CHOICES = [
        ("confirmed", "Confirmed"),
        ("tentative", "Tentative"),
        ("cancelled", "Cancelled"),
        ("completed", "Completed"),
    ]

    session_schedule = models.OneToOneField(
        SessionSchedule, on_delete=models.CASCADE, related_name="scheduled_session"
    )
    scheduled_datetime = models.DateTimeField()
    duration_hours = models.PositiveIntegerField(default=4)
    status = models.CharField(
        max_length=20, choices=STATUS_CHOICES, default="confirmed"
    )

    participants = models.ManyToManyField(PlayerAvailability, blank=True)

    session_notes = models.TextField(blank=True)
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        ordering = ["scheduled_datetime"]

    def __str__(self):
        return f"Session: {self.session_schedule.campaign.title} - {self.scheduled_datetime.strftime('%Y-%m-%d %H:%M')}"

    @property
    def end_datetime(self):
        return self.scheduled_datetime + timezone.timedelta(hours=self.duration_hours)

